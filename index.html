<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>151 Trading Strategies</title>

    <!-- Choices.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js@10.2.0/public/assets/styles/choices.min.css">

    <!-- Choices.js JS -->
    <script src="https://cdn.jsdelivr.net/npm/choices.js@10.2.0/public/assets/scripts/choices.min.js"></script>

    <!-- Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        /* ========== CSS Reset & Base ========== */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* ========== Dark Theme Variables ========== */
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f0f1a;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --accent-blue: #2962ff;
            --accent-green: #00c853;
            --accent-red: #ff5252;
            --accent-orange: #ff6d00;
            --accent-purple: #aa00ff;
            --accent-yellow: #ffd600;
            --border-color: #2a2a4a;
        }

        /* ========== Base Styles ========== */
        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* ========== Utility Classes ========== */
        .text-green { color: var(--accent-green); }
        .text-red { color: var(--accent-red); }
        .text-muted { color: var(--text-secondary); }
    </style>
</head>
<body>
    <!-- Row 1: Symbol, Timeframe, Status -->
    <div id="row1" class="control-row">
        <div class="control-group">
            <select id="symbol-select">
                <option value="BTC">BTC</option>
            </select>
            <select id="timeframe-select">
                <!-- Populated by JS -->
            </select>
        </div>
        <div class="status-indicator" id="status-indicator">
            <span class="status-dot"></span>
            <span class="status-text">Connecting...</span>
        </div>
    </div>

    <!-- Row 2: Strategies, Threshold, Confluence -->
    <div id="row2" class="control-row">
        <div class="strategy-slots" id="strategy-slots">
            <div class="strategy-slot" id="strategy-slot-1">
                <select class="strategy-select" data-slot="1">
                    <option value="">+ Add Strategy</option>
                </select>
                <button class="settings-btn" data-slot="1" style="display:none;">⚙</button>
            </div>
            <!-- More slots added dynamically -->
        </div>
        <div class="confluence-controls">
            <label>
                Threshold:
                <input type="range" id="threshold-slider" min="1" max="5" value="3">
                <span id="threshold-value">3</span>
            </label>
            <div class="confluence-badge" id="confluence-badge">
                <span>No strategies</span>
            </div>
        </div>
    </div>

    <!-- Settings Panel (hidden by default) -->
    <div id="settings-panel" class="settings-panel" style="display:none;">
        <div class="settings-header">
            <span id="settings-title">Strategy Settings</span>
            <button id="settings-close">×</button>
        </div>
        <div id="settings-content">
            <!-- Populated dynamically -->
        </div>
    </div>

    <!-- Chart Container -->
    <div id="chart-container"></div>

    <!-- Signal Log (collapsed) -->
    <div id="signal-log" class="signal-log collapsed">
        <div class="signal-log-header" id="signal-log-toggle">
            <span>▶ Signals (<span id="signal-count">0</span>)</span>
            <button id="export-csv-btn">Export CSV</button>
        </div>
        <div class="signal-log-content" id="signal-log-content">
            <!-- Populated dynamically -->
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <script>
// ============================================================
// SECTION 1: CONSTANTS & CONFIGURATION
// ============================================================

const CONFIG = {
    defaultSymbol: 'BTC',
    defaultTimeframe: '1h',
    defaultThreshold: 3,
    candleLimit: 500,
    maxStrategies: 5,
    retryDelays: [1000, 2000, 4000, 8000],
};

// ============================================================
// SECTION 1.5: CONNECTION STATE
// ============================================================

const ConnectionState = {
    CONNECTING: 'connecting',
    CONNECTED: 'connected',
    RECONNECTING: 'reconnecting',
    DISCONNECTED: 'disconnected'
};

let connectionState = ConnectionState.DISCONNECTED;
let connectionStateListeners = [];

function setConnectionState(state) {
    connectionState = state;
    connectionStateListeners.forEach(fn => fn(state));
    console.log('Connection state:', state);
}

function onConnectionStateChange(listener) {
    connectionStateListeners.push(listener);
}

const TIMEFRAMES = ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '8h', '12h', '1d', '3d', '1w', '1M'];

// ============================================================
// SECTION 2: DATA PROVIDER INTERFACE
// ============================================================

/**
 * DataProvider Interface (documentation only - JS has no interfaces)
 *
 * Any data provider must implement:
 * - name: string
 * - async getSymbols(): Promise<{symbol: string, name: string}[]>
 * - async fetchCandles(symbol, interval, limit): Promise<Candle[]>
 * - subscribeCandles(symbol, interval, onCandle): void
 * - unsubscribe(): void
 *
 * Candle format:
 * { time: number, open: number, high: number, low: number, close: number, volume: number }
 */

// Placeholder - will be replaced in Task 2.2
let dataProvider = null;

// ============================================================
// SECTION 3: HYPERLIQUID DATA PROVIDER
// ============================================================

const HyperliquidProvider = {
    name: 'hyperliquid',

    // REST endpoint
    baseUrl: 'https://api.hyperliquid.xyz/info',

    // WebSocket endpoint (used later)
    wsUrl: 'wss://api.hyperliquid.xyz/ws',

    // WebSocket connection (initialized later)
    ws: null,

    /**
     * Get available trading symbols
     * @returns {Promise<{symbol: string, name: string}[]>}
     */
    async getSymbols() {
        try {
            const response = await fetch(this.baseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ type: 'meta' })
            });
            const data = await response.json();

            // Extract perpetual symbols from universe
            return data.universe.map(item => ({
                symbol: item.name,
                name: item.name
            }));
        } catch (error) {
            console.error('Failed to fetch symbols:', error);
            throw error;
        }
    },

    /**
     * Fetch historical candles
     * @param {string} symbol - e.g., 'BTC'
     * @param {string} interval - e.g., '1h'
     * @param {number} limit - number of candles
     * @returns {Promise<Candle[]>}
     */
    async fetchCandles(symbol, interval, limit = 500) {
        try {
            // Calculate start time (go back enough to get `limit` candles)
            const intervalMs = this._intervalToMs(interval);
            const endTime = Date.now();
            const startTime = endTime - (limit * intervalMs);

            const response = await fetch(this.baseUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    type: 'candleSnapshot',
                    req: {
                        coin: symbol,
                        interval: interval,
                        startTime: startTime,
                        endTime: endTime
                    }
                })
            });

            const data = await response.json();

            // Normalize to our candle format
            return data.map(candle => ({
                time: Math.floor(candle.t / 1000), // Convert ms to seconds for LWC
                open: parseFloat(candle.o),
                high: parseFloat(candle.h),
                low: parseFloat(candle.l),
                close: parseFloat(candle.c),
                volume: parseFloat(candle.v)
            }));
        } catch (error) {
            console.error('Failed to fetch candles:', error);
            throw error;
        }
    },

    /**
     * Convert interval string to milliseconds
     * @private
     */
    _intervalToMs(interval) {
        const units = {
            'm': 60 * 1000,
            'h': 60 * 60 * 1000,
            'd': 24 * 60 * 60 * 1000,
            'w': 7 * 24 * 60 * 60 * 1000,
            'M': 30 * 24 * 60 * 60 * 1000
        };
        const match = interval.match(/^(\d+)([mhdwM])$/);
        if (!match) throw new Error(`Invalid interval: ${interval}`);
        return parseInt(match[1]) * units[match[2]];
    },

    /**
     * Subscribe to real-time candle updates
     * @param {string} symbol
     * @param {string} interval
     * @param {function} onCandle - callback receiving normalized candle
     */
    subscribeCandles(symbol, interval, onCandle) {
        this.unsubscribe();
        setConnectionState(ConnectionState.CONNECTING);

        this.ws = new WebSocket(this.wsUrl);
        this._onCandle = onCandle;
        this._currentSymbol = symbol;
        this._currentInterval = interval;
        this._reconnectAttempt = 0;

        this.ws.onopen = () => {
            console.log('WebSocket connected');
            setConnectionState(ConnectionState.CONNECTED);
            this._reconnectAttempt = 0;

            this.ws.send(JSON.stringify({
                method: 'subscribe',
                subscription: {
                    type: 'candle',
                    coin: symbol,
                    interval: interval
                }
            }));
        };

        this.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                if (message.channel === 'candle' && message.data) {
                    const candle = message.data;
                    const normalized = {
                        time: Math.floor(candle.t / 1000),
                        open: parseFloat(candle.o),
                        high: parseFloat(candle.h),
                        low: parseFloat(candle.l),
                        close: parseFloat(candle.c),
                        volume: parseFloat(candle.v)
                    };
                    this._onCandle(normalized);
                }
            } catch (err) {
                console.error('WebSocket message parse error:', err);
            }
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        this.ws.onclose = () => {
            console.log('WebSocket closed');
            this._handleReconnect(symbol, interval, onCandle);
        };
    },

    _handleReconnect(symbol, interval, onCandle) {
        if (this._reconnectAttempt >= CONFIG.retryDelays.length) {
            setConnectionState(ConnectionState.DISCONNECTED);
            console.error('Max reconnection attempts reached');
            return;
        }

        setConnectionState(ConnectionState.RECONNECTING);
        const delay = CONFIG.retryDelays[this._reconnectAttempt];
        console.log(`Reconnecting in ${delay}ms... (attempt ${this._reconnectAttempt + 1})`);

        setTimeout(() => {
            this._reconnectAttempt++;
            this.subscribeCandles(symbol, interval, onCandle);
        }, delay);
    },

    /**
     * Unsubscribe and close WebSocket connection
     */
    unsubscribe() {
        if (this.ws) {
            // Send unsubscribe before closing
            if (this.ws.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({
                    method: 'unsubscribe',
                    subscription: {
                        type: 'candle',
                        coin: this._currentSymbol,
                        interval: this._currentInterval
                    }
                }));
            }
            this.ws.close();
            this.ws = null;
        }
    }
};

// Set as the active provider
dataProvider = HyperliquidProvider;
    </script>
</body>
</html>
